<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1.3_汇编(多段程序及内存定位)]]></title>
    <url>%2F2018%2F03%2F22%2F1.3_%E6%B1%87%E7%BC%96(%E5%A4%9A%E6%AE%B5%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%86%85%E5%AD%98%E5%AE%9A%E4%BD%8D)%20%2F</url>
    <content type="text"><![CDATA[——《编程语言》 王爽 著 多段程序我们现在知道内存可以数据段，代码段，栈空间；那么当我们在一个程序中同时包含数据和代码时，从内存角度来看，我们应该怎么解决这个问题呢？ 在一个段中存放数据、代码、栈； 将数据、代码、栈放入不同的段中。 在代码段中使用程序先看下列程序：123456789101112131415assume cs:codecode segment dw 0123h,0456h,0789h,0abch,0defh,ofedh,0cbah,0987h start: mov bx,0 mov bx,0 mov cx,0 s: add ax,cs:[bx] add bx,2 loop s mov ax,4c00h int 21hcode endsend start 需要说明的几个问题： 1 dw的含义是define word，在这里，使用dw定义了8个字型数据；2 end 后面的 start表明了程序的入口。end除了通知编译器程序在这里结束外，还可以通知编译器程序的入口在什么地方；3 通过这种方法生成的数据，这8个数据存在于代码段的最开始，所以偏移地址为0,然后依次递增，8个字型数据存在于代码段的偏移0，2，4，6，8，A，C，E处。 在代码段中使用栈程序的大概思路为先”dw”8个字型空间留给要用的数据，然后”dw”8个字型空的空间留做栈空间用。假如我们设计将cs:10～cs:2F用做栈空间，那么需要在初始化设置时将cs段地址赋予ss中（中间经过ax寄存器做桥梁），然后将sp指向30h。 将数据、代码、栈放入不同的段将数据、代码、栈都放在一起存在两个缺点： 把它们放到一个段中使程序显得混乱； 如果需要的空间超过64kb，既不能放在一个段中（8086模式中一个段的容量不能超过64kb）。 程序大概格式如下：12345678910111213141516171819assume cs:code,ds:data,ss:stackdata segment...data endsstack segment...stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,20h ;指向栈顶 mov ax,data mov ds,ax ;指向data段...code endsend start 这个代码一共定义了三段空间，通过名称“data”等来传递段地址，即在进行空间的定义的时候，在物理上就将三个空间分开，然后调用其相应的段地址即可。此处再进行强调依次，在对段地址寄存器进行操作的时候，不能直接对其赋值，而应通过ax等寄存器作为桥梁。 更灵活的内存定位基础知识点： and和or指令的用法； 通过db ‘（字母）’的形式将对应的ASCII码值提取出来，db的意思是define byte； 字母的大小写转换问题，仔细研究一下ASCII表中大小写字母的区别，差值固定； [bx + idata] 的意思是 [（bx）+ idata]（意义：为高级语言实现数组提供了便利机制）； 提供了SI，DI两个16位寄存器，但是这两个寄存器并不能拆分成两个8位寄存器，功能和BX相近； 结论： [idata]用一个常量来表示地址，可用于直接定位一个内存单元； [bx]用一个变量来表示内存地址，可用于间接定位一个内存单元； [bx+idata]用一个变量和常量表示地址，可在一个其实地址的基础上用变量简洁的定位一个内存单元； [bx+si]用两个变量表示地址； [bx+si+idata]用两个变量和一个常量表示地址。]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2_汇编(loop)]]></title>
    <url>%2F2018%2F03%2F22%2F1.2_%E6%B1%87%E7%BC%96(loop)%2F</url>
    <content type="text"><![CDATA[——《编程语言》 王爽著 loop定义CPU执行loop指令的时候，要进行两步操作: 1 (cx) = (cx) - 12 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行 其中，cx为CX寄存器。 编程案例编程计算2^12的值 assume cs:codecode segmentmov ax,2 mov cx,11s: add ax,axloop s mov ax,4c00hint 21hcode endsend 分析上述程序：在汇编语言中，标号代表一个地址，s即是此程序中的标号,在loop ： s语句中执行以下步骤： 1 (cx) = (cx) - 12 判断cx中的值，不为0则转至标号s所标识的地址处执行（这里的指令是add ax,ax），如果为零则执行下一条指令（下一条指令是mov ax,4c00h)。 此处add ax,ax指令共执行了11次。这里要注意的是,loop s 下面的语句是用来返回8086系统的cmd进程中的，与此处的知识点无关，如果有兴趣可以找时间研究。 2. 实验 编程，向内存0：200～0：23F依次传送数据0～63（3FH）。 实现上述功能，且不能超过9条指令，且指令中应该包括mov ax,4c00h 和 int 21h。]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1_汇编(内存操作思考)]]></title>
    <url>%2F2018%2F03%2F21%2F1.1_%E6%B1%87%E7%BC%96(%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%80%9D%E8%80%83)%2F</url>
    <content type="text"><![CDATA[——《汇编语言第三版》 王爽 问题提出 存储在内存中的都是二进制数，如何区分指令，数据和栈空间？ 基础知识CS 和 IP定义CS是代码段寄存器，IP是指令指针寄存器。 用法如果需要到20003H处寻找指令，即CS：IP = 2000：0003。可以 jmp 2000:3, 此句执行后，CS = 2000H，IP=0003H，CPU将从20003H处读取指令。物理地址：20003H = 2000H（段地址） × 16 + 0003H（偏移地址）。（此处之所以×16是因为在8086CPU合成地址的规定，并不具备普遍意义。） 只要符合“段地址×规定倍率 + 偏移地址”格式得到的最终物理地址均有效，允许出现段地址与偏移地址不相同但是最终物理地址相同的情况。 注意事项 8086CPU的工作过程可以描述如下： 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲区； IP=IP+所读取的指令的长度，从而指向下一条指令； 执行指令。转到步骤1,重复这个过程。 在8086CPU中，无法直接对CS及IP寄存器进行操作，而通过“jmp 段地址：偏移地址”的指令进行对CS和IP寄存器的修改。 DS 和 [Adress]定义 CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086中，内存地址有段地址和偏移地址组成。 上段所说的指向数据内存的段地址寄存器为DS。 用法假如我们需要访问10000H单元的内容，可以用如下的程序段进行： mov bx,1000Hmov ds,bxmov al,[0] 上述的3条指令将10000H（1000：0）中的数据读到al。 注意事项完成上述指令目标时，为什么不能用下面的指令实现？ mov ds,1000H 即思考为什么不能将数值直接送入DS寄存器？关于这一点，这是因为8086的CPU硬件设计部分的原因，感兴趣可以自己进行寻找答案。 SS 和 SP定义8086CPU用SS和SP指示栈顶的位置，SS为段地址，SP为偏移地址。常与push和pop指令连在一起用。在这使用的过程中，假如我们定义的栈空间为指定大小x，栈空间的其实地址为a。那么可能出现栈满时执行push或着栈空的时候执行pop带来的“栈顶超界”问题，8086并没有提供有关记录栈顶空间的寄存器，需要编程者自己注意。 用法 mov ax,1000Hmov ss,axmov sp,0010Hpush axpush bxpush ds 上述指令执行了以下几个操作 将1000H放入AX寄存器 将栈段地址寄存器赋值1000H 将栈偏移地址寄存器赋值0010H 将AX寄存器的值压入栈 将BX寄存器的值压入栈 将DS寄存器的值压入栈 注意事项 在汇编操作的过程中，8086CPU并不支持直接将值赋予SS寄存器，但是可以直接将值赋予SP寄存器。 在入栈时，地址是从高向低增长。 思考 内存里是二进制数，并不具备所谓的数据、命令、栈空间的区别，全都是一个个的二进制数； 当CS、IP指向的是命令，DS、[Adress]指向的是数据，SS、SP指向栈空间的栈顶数据。]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.0_汇编语言（写在前面）]]></title>
    <url>%2F2018%2F03%2F20%2F1.0_%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4)%2F</url>
    <content type="text"><![CDATA[——《汇编语言第三版》 王爽 前言因为最近实在是遇到了项目上的困难，加上在计算机领域的经验很少，隔行如隔山，只能抱着虚心学习的态度，从基础看起。 更新博文主要目的是为了自己回顾的时候可以少走写弯路，所得均是从书上阅读与思考。 因为总结的目的是很大部分是为了自己，所以在我已经熟知的知识上给予了跳过，但是这部分可能是很重要的知识。 如果有后来者希望仅仅通过这一系列文章即对汇编有个大致的了解，我希望大家可以通过渠道去阅读王爽的《汇编语言》，通俗易懂。 欢迎通过邮箱及其他平台进行交流:)]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
</search>
