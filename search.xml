<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1.2_汇编(loop)]]></title>
    <url>%2F2018%2F03%2F22%2F1-2-%E6%B1%87%E7%BC%96-loop%2F</url>
    <content type="text"><![CDATA[——《编程语言》 王爽著 loop定义CPU执行loop指令的时候，要进行两步操作: 1 (cx) = (cx) - 12 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行 其中，cx为CX寄存器。 编程案例编程计算2^12的值 assume cs:codecode segmentmov ax,2 mov cx,11s: add ax,axloop s mov ax,4c00hint 21hcode endsend 分析上述程序：在汇编语言中，标号代表一个地址，s即是此程序中的标号,在loop ： s语句中执行以下步骤： 1 (cx) = (cx) - 12 判断cx中的值，不为0则转至标号s所标识的地址处执行（这里的指令是add ax,ax），如果为零则执行下一条指令（下一条指令是mov ax,4c00h)。 此处add ax,ax指令共执行了11次。这里要注意的是,loop s 下面的语句是用来返回8086系统的cmd进程中的，与此处的知识点无关，如果有兴趣可以找时间研究。 2. 实验 编程，向内存0：200～0：23F依次传送数据0～63（3FH）。 实现上述功能，且不能超过9条指令，且指令中应该包括mov ax,4c00h 和 int 21h。]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1_汇编语言（内存操作思考）]]></title>
    <url>%2F2018%2F03%2F21%2F1.1_%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%80%9D%E8%80%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[——《汇编语言第三版》 王爽 问题提出 存储在内存中的都是二进制数，如何区分指令，数据和栈空间？ 基础知识CS 和 IP定义CS是代码段寄存器，IP是指令指针寄存器。 用法如果需要到20003H处寻找指令，即CS：IP = 2000：0003。可以 jmp 2000:3, 此句执行后，CS = 2000H，IP=0003H，CPU将从20003H处读取指令。物理地址：20003H = 2000H（段地址） × 16 + 0003H（偏移地址）。（此处之所以×16是因为在8086CPU合成地址的规定，并不具备普遍意义。） 只要符合“段地址×规定倍率 + 偏移地址”格式得到的最终物理地址均有效，允许出现段地址与偏移地址不相同但是最终物理地址相同的情况。 注意事项 8086CPU的工作过程可以描述如下： 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲区； IP=IP+所读取的指令的长度，从而指向下一条指令； 执行指令。转到步骤1,重复这个过程。 在8086CPU中，无法直接对CS及IP寄存器进行操作，而通过“jmp 段地址：偏移地址”的指令进行对CS和IP寄存器的修改。 DS 和 [Adress]定义 CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086中，内存地址有段地址和偏移地址组成。 上段所说的指向数据内存的段地址寄存器为DS。 用法假如我们需要访问10000H单元的内容，可以用如下的程序段进行： mov bx,1000Hmov ds,bxmov al,[0] 上述的3条指令将10000H（1000：0）中的数据读到al。 注意事项完成上述指令目标时，为什么不能用下面的指令实现？ mov ds,1000H 即思考为什么不能将数值直接送入DS寄存器？关于这一点，这是因为8086的CPU硬件设计部分的原因，感兴趣可以自己进行寻找答案。 SS 和 SP定义8086CPU用SS和SP指示栈顶的位置，SS为段地址，SP为偏移地址。常与push和pop指令连在一起用。在这使用的过程中，假如我们定义的栈空间为指定大小x，栈空间的其实地址为a。那么可能出现栈满时执行push或着栈空的时候执行pop带来的“栈顶超界”问题，8086并没有提供有关记录栈顶空间的寄存器，需要编程者自己注意。 用法 mov ax,1000Hmov ss,axmov sp,0010Hpush axpush bxpush ds 上述指令执行了以下几个操作 将1000H放入AX寄存器 将栈段地址寄存器赋值1000H 将栈偏移地址寄存器赋值0010H 将AX寄存器的值压入栈 将BX寄存器的值压入栈 将DS寄存器的值压入栈 注意事项 在汇编操作的过程中，8086CPU并不支持直接将值赋予SS寄存器，但是可以直接将值赋予SP寄存器。 在入栈时，地址是从高向低增长。 思考 内存里是二进制数，并不具备所谓的数据、命令、栈空间的区别，全都是一个个的二进制数； 当CS、IP指向的是命令，DS、[Adress]指向的是数据，SS、SP指向栈空间的栈顶数据。]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.0_汇编语言（写在前面）]]></title>
    <url>%2F2018%2F03%2F20%2F1.0_%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4)%2F</url>
    <content type="text"><![CDATA[——《汇编语言第三版》 王爽 前言因为最近实在是遇到了项目上的困难，加上在计算机领域的经验很少，隔行如隔山，只能抱着虚心学习的态度，从基础看起。 更新博文主要目的是为了自己回顾的时候可以少走写弯路，所得均是从书上阅读与思考。 因为总结的目的是很大部分是为了自己，所以在我已经熟知的知识上给予了跳过，但是这部分可能是很重要的知识。 如果有后来者希望仅仅通过这一系列文章即对汇编有个大致的了解，我希望大家可以通过渠道去阅读王爽的《汇编语言》，通俗易懂。 欢迎通过邮箱及其他平台进行交流:)]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
</search>
