<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解计算机系统（1）]]></title>
    <url>%2F2018%2F04%2F16%2F3.1_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[写在前面最近有个项目需要：在codewarrior上实现两个设计上割裂的功能之间相互调用，想要完成这个简单的功能，我进行了以下努力： 先去了解汇编，得到了一种原理上的可行性； 在codewarrior上试图实现c和汇编进行混编，结果被告知需要研究官方提供的说明文档； 官方的说明文档的阅读需求需要编译原理的相关基础； 调研编译原理，购买了本《编译原理》，但是向有经验的前辈请教时，被告知阅读编译原理时，最好有《计算机组成原理》方面的基础。 综上所述，争取在编译原理未寄来之前，对《深入理解计算机系统》这本书有个预览。 1 第1章总结计算机系统是由硬件和系统软件组成的，他们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据不同的上下文又有不同的解释方式。程序被其他程序翻译成不同的形式，开始是ASCII文本，然后被翻译器和链接器翻译成二进制可执行文件。处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在存储器，I/O设备和CPU寄存器之间拷贝数据，所以系统中的存储设备就被按层次排列，CPU寄存器在顶部，接着是多层的硬件告诉缓存存储器，DRAM主存储器和磁盘存储器。在层次模型中位于更高层的存储设备比低层的存储设备要快，单位比特造价也更高。程序员通过理解和运用这种存储层次结构的知识，可以优化他们C程序的性能。操作系统的内核是应用程序和硬件之间的媒介。它提供三个基本的抽象概念：文件是对I/O设备的抽象概念。最后，网络提供了计算机系统之间通信的手段。从某个系统的角度来看，网络就是一种I/O设备。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2线性代数（行列式）]]></title>
    <url>%2F2018%2F04%2F13%2F2.2%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0(%E8%A1%8C%E5%88%97%E5%BC%8F)%2F</url>
    <content type="text"><![CDATA[从这一章开始，偏向于自我总结，受益人主要是自己，让自己可以时间利用最大化。像第一章的进度太慢了，写公式什么的时间占用太多，目前看来单位时间的收益率太低。开始做其他总结方式的尝试。 前言每一个方形矩阵可以和一个称为矩阵行列式的实数相对应。这个数值将告诉我们矩阵是否是奇异的。 2.1 矩阵的行列式对每一个$n*n$的矩阵$A$，均可对应一个标量$det(A)$，它的值将告诉我们矩阵是否是非奇异的。 行列式 子式 余子式 定理： 矩阵A转置的行列式 $=$ 矩阵A的行列式； 矩阵A的行列式可以利用其 标量及其标量对应的余子式 求出； 矩阵A是三角形矩阵，则A的行列式等于A的对角元素的乘积； 若矩阵A存在一行或者一列元素相等 或 有两行或两列相等，那么矩阵的行列式为0； 2.2 行列式的性质性质： 矩阵A的标量（按行或者列展开）和标量对应的余子式的乘积相加，得到其行列式，但如果并不是对应的余子式带入方程，其值为0； 交换矩阵的两行（或列）改变行列式的符号； 矩阵的某行或列乘以一个标量的作用是将行列式乘以这个标量； 将某行（或列）的倍数加到其他行（或列）上不改变行列式的值。 结论： 一个矩阵A奇异的充要条件是：$det(A)=0$; 若A和B均为$n*n$矩阵，则$det(AB)=det(A)det(B)$。 2.3 附加主题和应用2.3.1 矩阵的伴随令A为一n×n矩阵，我们定义一个新矩阵，称为矩阵A的伴随（adjoint）。\begin{equation}adj A =\left[\begin{array}{cccc}A_{11}&amp;A_{21}&amp;\cdots&amp;A_{n1}\\A_{12}&amp;A_{22}&amp;\cdots&amp;A_{n2}\\\vdots&amp;&amp;&amp;\\A_{1n}&amp;A_{2n}&amp;\cdots&amp;A_{nn}\\\end{array}\right]\end{equation}需要注意的是，矩阵A按行展开的标量对应的余子式，在伴随矩阵以列的形式存在。即原矩阵的第一行的代数余子式为是伴随矩阵的第一列。关于伴随矩阵，有以下两个思考： 用原矩阵乘以其伴随矩阵，除以其行列式的值，是单位矩阵； 因为思考1,$A^{-1}=\frac{1}{det(A)}*adjA$ 2.3.2 克拉默法则\begin{equation}x_i=\frac{det(A_i)}{det(A)}\end{equation}此方法虽然提供了一种计算线性方程组的便利方法，但即使计算两个这样的行列式，通常也要用多于高斯消元法的计算量。 2.3.3 向量积向量积的符号是×（叉乘）。两个向量叉乘后，得到的仍然是一个向量，该向量与两个原向量的方向垂直，大小是两个原向量大小乘积与两个向量之间夹角的正弦值的乘积。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1线性代数（矩阵与方程组）]]></title>
    <url>%2F2018%2F04%2F11%2F2.1%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0(%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%96%B9%E7%A8%8B%E7%BB%84)%2F</url>
    <content type="text"><![CDATA[前言随着越深入的学习专业知识，越觉得自身在数学方面的基础实在薄弱，故从今天开始从头啃书，本次学习的教材是Steven J.Leon的《Linear Algebra with Applications》。之所以选择这本书的原因是想看一看外国教材对于线性代数有没有独到的知识体系，虽然从调研的结果来看Gilbert Strang的《Introduction to Linear Algebra》的口碑更佳，无奈原版书太贵，网上有一些“热心人”会分享电子版，我会同时参考两本书进行线性代数的学习。 1. 线性方程组1.1 相容/不相容 方程组如下方程组：\begin{aligned}4+x_2&amp;=2\\4-x_2&amp;=1\\\end{aligned}因为不存在实数能同时满足上述两个方程，故方程组无解。如果线性方程组无解，则称该方程组是不相容的（inconsistent）。如果线性方程组至少存在一个解，则称该方程组是相容的（consistent）。 1.2 方程组的解集线性方程组的所有解的集合称为方程组的解集（solution set）。如果方程组不相容，则其解集为空集。相容的线性方程组解集必非空。因此，求解线性方程组，就是寻找其解集。 1.3 “等价”方程组若两个含有相同变量的方程组具有相同的解集则称他们是等价的（equivalet）。共有三种运算可以得到等价的方程组： 交换任意两个方程的顺序； 任意方程两边同乘一个非零的实数； 任一方程的倍数加到另一方程上。 对于给定的方程组，可以使用这些运算得到一个容易求解的等价方程组。 1.4 方便求解的方程组形式——严格三角形若方程组中，第$k$个方程的前$k-1$个变量的系数均为零，且$x_k(k=1,\cdots,n)$的系数不为零，则称该方程组为严格三角形的（strict triangular form）。如下例：\begin{aligned}3x_1 + 2x_2 + x_3 &amp;= 1\\x_2 - x_3 &amp;= 2\\2x_3 &amp;= 4\end{aligned}即为严格三角形的，因此容易求解——由最后一个方程依次向上迭代即可。称这种求解严格三角形方程组的办法为回代法（back substitution）。 1.5 方程组对应的“系数矩阵”写下一个方程组：\begin{aligned}x_1+2x_2+x_3&amp;=3\\3x_1-1x_2-3x_3&amp;=-1\\2x_1+3x_2+x_3&amp;=4\end{aligned}将上述方程组与一个以$x_i$的系数为元的$3*3$数字阵列联系起来。 \begin{equation}\left[\begin{array}{rrr}1&amp;2&amp;1\\3&amp;-1&amp;-3\\2&amp;3&amp;1\end{array}\right]\end{equation} 这个阵列称为方程组的系数矩阵（coefficient matrix）。简单的说，矩阵（matrix）就是一个矩形的数字阵列。如果在系数矩阵右侧添加一列方程组的右端项，可得到一个新的矩阵：\begin{equation}\left[\begin{array}{rrr|r}1 &amp; 2 &amp; 1 &amp; 3\\3 &amp; -1 &amp; -3 &amp; -1\\2 &amp; 3 &amp; 1 &amp; 4\end{array}\right]\end{equation}这个矩阵称作方程组的增广矩阵（augmented matrix）。对应于一开始提到的方程组。用于得到等价方程组的三个计算，可对应于下列增广矩阵的行运算。 初等行运算： 交换两行； 以非零实数乘以某行； 将某行替换为它与其他行的倍数的和。 对增广矩阵处理的例子如下：\begin{equation} \left[ \begin{array}{rrr|r} 1 &amp; 2 &amp; 1 &amp; 3 \\ 3 &amp; -1 &amp; -3 &amp; -1 \\ 2 &amp; 3 &amp; 1 &amp; 4 \end{array} \right] = \left[ \begin{array}{rrr|r} 1 &amp; 2 &amp; 1 &amp; 3 \\ 0 &amp; -7 &amp; -6 &amp; -10 \\ 0 &amp; -1 &amp; -1 &amp; -2 \end{array} \right] = \left[ \begin{array}{rrr|r} 1 &amp; 2 &amp; 1 &amp; 3 \\ 0 &amp; -7 &amp; -6 &amp; -10 \\ 0 &amp; 0 &amp; -\frac{1}{7} &amp; -\frac{4}{7} \end{array} \right]\end{equation}最后得到的增广矩阵，即是与源方程组等价的严格三角形方程组的增广矩阵。使用回代法容易得到此方程的解。 2. 行阶梯形2.1 如何得到“行阶梯形”上节中介绍了将n×n的线性方程组化简为严格三角形方程组的办法。但是，若在化简过程中的某一步，主元所有可能的选择只能是0,上述介绍的方法将无法继续下去。例：考虑如下增广矩阵表示的方程组：\begin{equation}\left[\begin{array}{rrrrr|r}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\-1 &amp; -1 &amp; 0 &amp; 0 &amp; 1 &amp; -1\\-2 &amp; -2 &amp; 0 &amp; 0 &amp; 3 &amp; 1\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 3 &amp; -1\\1 &amp; 1 &amp; 2 &amp; 2 &amp; 4 &amp; 1\\\end{array}\right]\end{equation}化简为：\begin{equation}\left[\begin{array}{rrrrr|r}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 3\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -4\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -3\\\end{array}\right]\end{equation}最终得到的系数矩阵不是严格的三角形的；它是阶梯形（staircase）的。 2.2 如何利用“行阶梯形”因为上述增广矩阵的后两行的原因，得知其所代表的方程组不相容，稍稍进行修改一下使其相容。\begin{equation}\left[\begin{array}{rrrrr|r}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 3\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\end{array}\right]\end{equation}增广矩阵每一行第一个非零元对应的变量称为首变量（lead variables），化简过程中跳过的列对应的变量称为自由变量（free variables）。因此，在上述增广矩阵对应的方程组中，$x_1,x_3,x_5$为首变量，$x_2,x_4$为自由变量。将自由变量移到等式右端，我们得到方程组：\begin{equation}\begin{aligned}x_1+x_3+x_5&amp;=1-x_2-x_4 \\x_3+2x_5&amp;=-x_4 \\x_5&amp;=3\end{aligned}\end{equation}对每一对给定的$x_2,x_4$，均存在唯一解。 2.3 “行阶梯形矩阵的定义”定义：若一个矩阵满足: 每一非零行中的第一个非零元为1； 第$k$行的元不全为零时，第$k+1$行首变量之前的零的个数多余第$k$行首变量之前零的个数； 所有元素均为零的行必在不全为零的行之后。 则称其为行阶梯形矩阵（row echelon form）。判断下列矩阵是否是行阶梯形矩阵：\begin{equation}\left[\begin{array}{rrr}2&amp;4&amp;6\\0&amp;3&amp;5\\0&amp;0&amp;4\end{array}\right],\left[\begin{array}{rrr}0&amp;0&amp;0\\0&amp;1&amp;0\end{array}\right],\left[\begin{array}{rr}0&amp;1\\1&amp;0\end{array}\right]\end{equation} 2.4 高斯消元法定义： 利用初等行运算，将线性方程组的增广矩阵化为行阶梯形的过程称为高斯消元法（Gaussian elimination）。 如含有如下形式的行：\begin{equation}\left[\begin{array}{rrrr|r}0&amp;0&amp;\cdots&amp;0&amp;1\\\end{array}\right]\end{equation}则该方程组不相容。否则，该方程组将相容。若方程组相容且行阶梯形矩阵的非零行构成了严格三角形方程组，则该方程组存在唯一解。 2.5 方程个数$\neq$未知量个数在实际的计算中，假如方程个数与未知量个数相等，且方程组不相关（这个概念后面会提到，简而言之就是方程组里面的任一方程并不能由其它方程线性组合得到）。那么方程组存在唯一解或无解。讨论方程个数与未知量个数不同的情况：方程个数$&gt;$未知量个数——超定方程组；方程个数$&lt;$未知量个数——亚定方程组 2.5.1 超定方程组超定方程组通常是（并不总是）不相容的。\begin{equation}\left[\begin{array}{rr|r}1&amp;1&amp;1\\1&amp;-1&amp;3\\-1&amp;2&amp;-2\end{array}\right]\Rightarrow\left[\begin{array}{rr|r}1&amp;1&amp;1\\0&amp;1&amp;-1\\0&amp;0&amp;1\end{array}\right]\end{equation}根据化简后最后一行可知该方程组并不相容。 2.5.2 亚定方程组亚定方程组通常是（并不总是）相容的，如果亚定方程组有解，那么不可能只有唯一解。假设环境：未知量个数为n，方程个数为m，亚定方程组中n$&gt;$m，而系数矩阵的行阶梯形矩阵必有r$&lt;=$m个非零行，因此必有r个首变量及$n-r$个自由变量，若方程组是相容的，我们可给自由变量任意赋值，求得首变量的值。因此，一个相容的亚定方程组将有无穷多组解。 2.6 行最简形 定义：若一个矩阵满足： 矩阵是行阶梯形的； 每一行的第一个非零元是该列唯一的非零元。则称该矩阵为行最简形（reduced row echelon form）。 采用基本行运算将矩阵化为行最简形的过程称为“高斯-若尔当消元法”（Gauss-Jordan redction）。下例采用高斯-若尔当消元法解方程组：\begin{equation}\left[\begin{array}{rrrr|r}-1&amp;1&amp;-1&amp;3&amp;0\\3&amp;1&amp;-1&amp;-1&amp;0\\2&amp;-1&amp;-2&amp;-1&amp;0\end{array}\right]\Rightarrow\left[\begin{array}{rrrr|r}-1&amp;1&amp;-1&amp;3&amp;0\\0&amp;4&amp;-4&amp;8&amp;0\\0&amp;1&amp;-4&amp;5&amp;0\end{array}\right]\\\Rightarrow\left[\begin{array}{rrrr|r}-1&amp;1&amp;-1&amp;3&amp;0\\0&amp;4&amp;-4&amp;8&amp;0\\0&amp;0&amp;-3&amp;3&amp;0\end{array}\right]\Rightarrow\left[\begin{array}{rrrr|r}1&amp;-1&amp;1&amp;-3&amp;0\\0&amp;1&amp;-1&amp;2&amp;0\\0&amp;0&amp;1&amp;-1&amp;0\end{array}\right]\\\Rightarrow\left[\begin{array}{rrrr|r}1&amp;-1&amp;0&amp;-2&amp;0\\0&amp;1&amp;0&amp;1&amp;0\\0&amp;0&amp;1&amp;-1&amp;0\end{array}\right]\Rightarrow\left[\begin{array}{rrrr|r}1&amp;0&amp;0&amp;-1&amp;0\\0&amp;1&amp;0&amp;1&amp;0\\0&amp;0&amp;1&amp;-1&amp;0\end{array}\right]\end{equation}若令$x_4$为任意实数a，则可以推出$x_1=a,x_2=-a,x_3=a$，形如这种的解均为方程组的解。 3. 矩阵算术本节将引入矩阵和向量的标准记号，并定义矩阵的算术运算（加减乘）。引入两种附加运算：标量乘法和转置。我们的目的是： 了解如何表示包含矩阵和向量的线性方程组； 推导出线性方程组相容的定理。 3.1 基本定义标量矩阵中的元素称为“标量（scalar）”。矩阵记号使用$a_{ij}$表示矩阵A的第i行第j列的元素，并用$(i,j)$表示它。有时还将矩阵简记为$A=(a_{ij})$。向量由于仅有一行或一列的矩阵可以用来表示线性方程组的解，因此特别值得注意。具有m个线性方程n个变量的线性方程组的解是一个实的n元组。我们以后称由实数组成的n元组为向量（vector）。如果n元组表示为一个1×n的矩阵，则称为行向量（row vector）。如果n元组表示为一个n×1的矩阵，则称为列向量（column vector）。所有n×1的实矩阵构成的集合称为n维欧几里得空间（Euclidean n-space）。相等若两个矩阵相等，则： 它们维数相等； 它们对应的元素必相等。定义： 若两个m*n矩阵A和B对任一$i$和$j$均满足$a_{ij}=b_{ij}$，则称他们是相等（equal）。 标量乘法设A为一矩阵，$\alpha$为一标量，则$\alpha$A为将A中的任一元素乘以$\alpha$而构成的一个矩阵。矩阵加法两个相同维数矩阵的加法可通过对应元素相加得到。定义： 设$A=(a_{ij})$和$B=(b_{ij})$都是mn矩阵，则他们的和（sum）A+B也是一个mn矩阵，对每一个有序对（i，j），它的（i，j）元素为$a_{ij}+b_{ij}$。 矩阵乘法及线性方程组 一个方程有多个未知量例如考虑方程：\begin{equation}3x_1+2x_2+5x_3=4\\\end{equation}若另：\begin{equation}A =\left[\begin{array}{rrr}3&amp;2&amp;5\end{array}\right]及x =\left[\begin{array}{r}x_1\\x_2\\x_3\end{array}\right]\end{equation}并定义乘以Ax为：\begin{equation}Ax=\left[\begin{array}{rrr}3&amp;2&amp;5\end{array}\right]\left[\begin{array}{r}x_1\\x_2\\x_3\end{array}\right]=3x_1+2x_2+5x_3\end{equation}注意，左侧的行向量与右侧的列向量乘积的结果为一个标量。因此这种乘法通常称为标量积（scalar product）。 m个方程n个未知量\begin{equation}\left{\begin{aligned}[c]a_{11}x_1+a_{12}x_2+a_{13}x_3&amp;=b_1\\a_{21}x_1+a_{22}x_2+a_{23}x_3&amp;=b_2\\a_{31}x_1+a_{32}x_2+a_{33}x_3&amp;=b_3\end{aligned}\right.\\\Downarrow\\\left[\begin{array}{rrr}a_{11}&amp;a_{12}&amp;a_{13}\\a_{21}&amp;a_{22}&amp;a_{23}\\a_{31}&amp;a_{32}&amp;a_{33}\end{array}\right]\left[\begin{array}{r}x_1\\x_2\\x_3\end{array}\right]=\left[\begin{array}{r}b_1\\b_2\\b_3\end{array}\right]\\\Downarrow\\x_1\left[\begin{array}{r}a_{11}\\a_{21}\\a_{31}\end{array}\right]+x_2\left[\begin{array}{r}a_{12}\\a_{22}\\a_{32}\end{array}\right]+x_3\left[\begin{array}{r}a_{13}\\a_{23}\\a_{33}\end{array}\right]=\left[\begin{array}{r}b_1\\b_2\\b_3\end{array}\right]\end{equation} 线性组合 若$a_1,a_2,\cdots,a_n$为$R^m$中的向量，且$c_1,c_2,\cdots,c_n$为标量，则和式：$c_1a_1+c_2a_2+\cdots+c_na_n$称为向量$a_1,a_2,\cdots,a_n$的一个线性组合（linear combination）。 符号规则正如通常的代数，如果表达式中既包含乘法也包含加法，且没有使用括号指明运算的顺序，那么乘法先于加法运算。这同样适用于标量乘法和矩阵乘法。矩阵的转置定义： 一个m×n矩阵A的转置（transpose）为n×m矩阵B，定义为$b_{ji}=a_{ij}$，其中$j=1,\cdots,n$和$i=1,\cdots,m$。A的转置为$A^{T}$。 定义： 一个n×n的矩阵A，若满足$A^T=A$，则称为对称的（symmetric）。 4 矩阵代数实数的代数法则可能适用也可能不适用矩阵。本节给出一些矩阵代数中有用的法则。 4.1 代数法则在下面的定理中给出了一些矩阵代数中有用的法则。 定理在定义了需要的运算后，下述法则对任何标量$\alpha$和$\beta$及矩阵A，B和C都是成立的。\begin{equation}\begin{aligned}[l]A+B&amp;=B+A\\(A+B)+C&amp;=A+(B+C)\\(AB)C&amp;=A(BC)\\A(B+C)&amp;=AB+AC\\(A+B)C&amp;=AC+BC\\(\alpha \beta)A&amp;=\alpha A+\beta A\\\alpha(AB)&amp;=(\alpha A)B\\&amp;=A(\alpha B)\\(\alpha + \beta)A&amp;=\alpha A+\beta A\\\alpha(A+B)&amp;=\alpha A+\alpha B\end{aligned}\end{equation}(在上述等式中，形如A、B表示为矩阵，形如为$\alpha,\beta$表示为实数，或者称为标量) 4.2 单位矩阵 定义：n×n的单位矩阵（identity martrix）为矩阵I=（$\delta$_{ij}），其中\begin{equation}\delta _{ij} =\left{\begin{aligned}[l]1(i=j)\\0(i \neq j)\end{aligned}\right.\end{equation} 4.3 矩阵的逆4.4 转置的代数法则4.5 对称矩阵和网络5 初等矩阵5.1 等价方程组5.2 初等矩阵如果从单位矩阵$I$开始，只进行一次初等行运算，得到的矩阵称为初等（elementary）矩阵。分别对应于三类初等行运算，有三类初等矩阵。 第一类初等矩阵由交换矩阵I的两行得到； 第二类初等矩阵由单位矩阵I的某一行乘以一个非零常数得到； 第三类初等矩阵由矩阵I的某一行的倍数加到另一行得到。 定理1.5.1：若E为一初等矩阵，则E是非奇异的，且$E^{-1}$为一与它同类型的初等矩阵。 定义：若存在一个有限初等矩阵的序列$E_1,E_2,\cdots,E_k$ 使得\begin{equation}\begin{aligned}[l]B=E_kE_{k-1}\cdots E_1A\end{aligned}\end{equation}则称A与B是等价的。 容易得到以下行等价矩阵的性质： 若A与B是行等价的，则B与A是行等价的； 若A与B是行等价的，且B与C是行等价的，则A与C是行等价的。 定理1.5.2：令A为一n×n矩阵，则下列命题是等价的： A是非奇异的； Ax=0仅有平凡解0； A与I行等价。 推论1.5.3：当且仅当A非奇异时，n个未知量n个方程的线性方程组Ax=b有唯一解。 5.3 对角矩阵和三角形矩阵 上三角矩阵严格三角形对应的系数矩阵必为对角元素非零的上三角矩阵。 下三角矩阵 对角矩阵对角矩阵即是上三角矩阵，也是下三角矩阵。 5.4 三角形分解观察矩阵B：\begin{equation}\begin{aligned}[l]B=E_kE_{k-1}\cdots E_1A\end{aligned}\end{equation}可以分解成\begin{equation}\begin{aligned}[l]E_kE_{k-1}\cdots E_1\end{aligned}和A\end{equation}两部分。左边可以整合成一个矩阵，形为下三角矩阵；右边是用行阶梯形化的矩阵，是上三角矩阵。结论是一个n×n矩阵可以分解成一个下三角矩阵和上三角矩阵的乘积，称为LU分解。6 分块矩阵通常，将矩阵看成由若干子矩阵复合而成很有用。一个矩阵C可通过在其行中画一条横线，并在其列中画一条竖线划分成较小的矩阵。这种较小的矩阵通常称为块（block）。 6.1 分块乘法假如A是一个m×n矩阵，B是一个n×r矩阵。经常将A和B分块，并将它们的乘积表示为她恩的子矩阵乘积的形式。考虑如下四种情形： \begin{equation}A\left[\begin{aligned}[rrr]B_1&amp;&amp;B_2\end{aligned}\right]=\left[\begin{aligned}[rrr]AB_1&amp;&amp;AB_2\end{aligned}\right]\end{equation} \begin{equation}\left[\begin{aligned}[r]A_1\\A_2\end{aligned}\right]B=\left[\begin{aligned}[r]A_1B\\A_2B\end{aligned}\right]\end{equation} \begin{equation}\left[\begin{aligned}[rrr]A_1&amp;&amp;A_2\end{aligned}\right]\left[\begin{aligned}[r]B_1\\B_2\end{aligned}\right]=A_1B_1+A_2B_2\end{equation} \begin{equation}A=\left[\begin{array}{ccc}A_{11}&amp;\cdots&amp;A_{1t}\\\vdots&amp;&amp;\\A_{s1}&amp;\cdots&amp;A_{st}\end{array}\right]\\B=\left[\begin{array}{ccc}B_{11}&amp;\cdots&amp;A_{1r}\\\vdots&amp;&amp;\\A_{t1}&amp;\cdots&amp;A_{tr}\end{array}\right]\\AB=\left[\begin{array}{ccc}C_{11}&amp;\cdots&amp;C_{1r}\\\vdots&amp;&amp;\\C_{s1}&amp;\cdots&amp;C_{sr}\end{array}\right]\end{equation}6.2 外积展开给定$R^n$中的两个向量x和y，若首先将其中一个向量转置，则这两个向量即可进行矩阵乘法。这里面会存在两种情况：一是一个行向量与一个列向量相乘，得到一个标量；这种乘积称为标量积（scalar product）或者内积（inner product）；二是一个列向量和行向量相乘，得到一个矩阵，称为外积（outer product）。外积展开在很多应用中起着重要的作用。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祝小公举生日快乐]]></title>
    <url>%2F2018%2F04%2F04%2F%E7%A5%9D%E5%B0%8F%E5%85%AC%E4%B8%BE%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%2F</url>
    <content type="text"><![CDATA[主题主题？主题当然是我家宝宝的生日啊，不然还能是什么？(=′ー`) 1. 我和某宝宝已经在一起1914天了还记得刚去大学的时候，第一次参加班级集体活动就是大合唱。男生女生分区站着，我对面啊，有个小姑娘，总是板着脸，每当学长开始说明讲解时就开始翻白眼，说一次翻一次，几乎没有例外(￣へ￣) 。 那时候就在想啊，这是谁家的小公举，咋这么傲娇，但又觉得可爱( ´･◡･` )。 大合唱后啊，一直没有交集呗，生活没有交点，我啊大部分时间喜欢在图书馆泡着，不是学习哈，就是看点小杂书，毕竟那时候还有一颗不成熟的文艺心 。(o゜_,゜o) 阴差阳错的被小公举邀请进了社团(→_←)，从那以后见面的机会就多啦，一起参加了几次社团活动(`･ω･´)，也打电话发短信ヽ( ｀0´)ﾉ；逢着期末考试，还一起去图书馆自习ᕦ(ò_óˇ)ᕤ。 结果当然就是，我幸运的和小公举牵手啦 (ˉ▽￣～)。 2. 想说又说不出口的话小公举嘛，总是要有点公举脾气才正常嘛。 (〜￣△￣)〜 我们俩说实话都是恋爱白痴，小公举在感情上比我成熟点，我一开始可是个实打实的混世大魔王，在感情上时常无理取闹.╮(﹀_﹀”)╭。 所以咯，经常会吵架，吵架就哭啊，哭完就和好啊，中间有时候也会牵扯到其他好多人，现在有时候回想起来恨不得自己找个地缝钻进去(⌇ຶД⌇ຶ) ——恨不得一棒子敲死过去的自己。 ( T﹏T ) 幸运的是啊，吵吵闹闹那么长时间，小公举包容我，迁就我，很多很多次，静下心来细细品味这段感情的时候，会有很多很多话想对她说，千言万语，百种滋味，到了嘴边却又一句话都说不出来。好幸运啊，可以碰到你。 我想啊，如果早一点或者晚一点碰到你，我们大概都不会在一起。如果那时候没有脑抽去投稿子，大概结局也是擦肩而过。如果你已然经历过社会的磨练，大概你不会容忍拥有一个那么幼稚的男朋友。如果我们在最苦难的时候选择放弃，大概也就没有后来的故事。 太多的如果了，太多的幸运了。我想上辈子我大概拯救了世界才会有这样的运气吧。 在公司年会上说了几句感谢，但是那时候的自己是敷衍的，表面文章，真正想要感谢的，是陪伴我这么长时间的小公举同志；是一直迁就着一个不成熟的男朋友，帮助他成长的优秀的小公举同志；是让她留了很多眼泪，吃了很多苦没有享受到小公举生活的名不副实的小公举同志，我欠的太多，大概需要用余生去照顾她，去弥补她。 我很想当面说感谢，可是又怕太矫情；我喜欢抱着她，对她说我喜欢她，可是说出的话大概表达不出我的喜欢的万分之一；我喜欢想我们以后的日子，可是又怕短时间内给不了她富足的物质生活，给不了她一个小公举应有的生活条件。 我害怕的太多，可是站在她的身边我也有着与之相等的勇气。亏欠太多就去偿还，喜欢太多就去行动。 希望余生，仍然可以和小公举互相指教。（＞ε＜） 深爱你的某某某 哈哈哈哈]]></content>
      <categories>
        <category>日常随笔</category>
      </categories>
      <tags>
        <tag>某宝宝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu（命令及桌面整理）]]></title>
    <url>%2F2018%2F03%2F23%2FUbuntu%EF%BC%88%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%A1%8C%E9%9D%A2%E6%95%B4%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[遇到的困难 电脑屏幕太小，想同时进行文档查看和文档撰写，特别不方便。 每次上传文件，都需要到目标文件夹里面去执行终端命令，感觉很繁琐。 解决问题的办法 下载了一个ubuntu的unity管理系统——Unity Tweak Tools。实现了以下几个功能： 1 可以自由的更换系统主题，主题图标；2 可以增加工作空间，快捷键ctrl+s，可以多设立几个工作空间，然后将不同的任务进行分配； 通过编写命令集合的shell文件来实现目的：比如我需要实现不用去目标文件夹即可以上传备份工作文件的目的： 1 先将要存放shell脚本的文件夹建立好，复制文件夹的路经；2 打开～目录下的.bashrc文件，加入路径作为环境变量（具体设置方法可以百度，此处只提供思路）；3 然后编写shell脚本，如我的脚本就是“声明，切换目录到指定文件夹，输入对应指令”；4 然后在任一地方打开终端，输入指令source [文件名]即可。（source bash sh都可，但取决于你定义的shell脚本的声明）。]]></content>
      <categories>
        <category>日常随笔</category>
      </categories>
      <tags>
        <tag>ubuntu桌面</tag>
        <tag>ubuntu命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.5_汇编(转移指令的原理)]]></title>
    <url>%2F2018%2F03%2F22%2F1.5_%E6%B1%87%E7%BC%96(%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86)%2F</url>
    <content type="text"><![CDATA[前言可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括的说，转移指令就是可以控制CPU执行内存中某处代码的指令。8086CPU的转移指令分为以下几类： 段间转移和段内转移段内转移分两种：短转移和近转移` 常用的转移指令操作符offset操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。给出下列程序段，填写两条指令，使该程序在运行中将s处的一条指令复制到s0处。1234567891011assume cs:codesg codesg segment s: mov ax,bx mov si,offset s mov di,offset s0 __________ __________ s0: nop nop codesg ends end s 提出以下几个问题： s和s0处的指令所在的内存单元的地址是多少？ 将s处的指令复制到s0处，如何进行操作？ 段地址已知在cs中，偏移地址offset s和offset s0已经送入si和di中。 要复制的数据有多长？ 思考所得： 通过“offset 标号”可以得到标号的地址； 在8086CPU中，得到的标号地址是八位数据。 jmp指令 根据位移进行转移的jmp指令jmp short 标号（转到标号处执行指令）这种情况下执行的jmp指令在机器指令里的跳转数据并不是目标程序（或标号）的地址，而是相对偏移地址，比如jmp的前一句指令的地址为a，跳转的目标指令的地址为b，在机器指令里，只出现b-a的值，并不直接指明地址b。这说明，CPU在执行jmp指令的时候并不需要转移的目的地址。 转移的目的地址在指令中的jmp指令jmp far ptr 标号上述指令实现的是段间转移，又称为远转移。可以同时修改CS和IP。 转移地址在寄存器中的jmp指令指令格式：jmp 16位reg这种修改方式只能修改IP，并不能修改CS 转移地址在内存中的jmp指令a、jmp word ptr 内存单元地址（段内转移）在内存单元地址处开始存放着一个字b、jmp dword ptr 内存单元地址（段间转移）在内存单元地址处开始存放着两个字 我是否可以这么理解？当我提供给jmp16位数据时，只进行IP的修改，即进行段内转移，当你提供给它32位数据时，它填满了IP，即会填充CS，实现段间转移。 jcxz条件转移指令jcxz 标号（如果（cx）==0,转移到标号处执行） loop指令loop指令为循环指令，所有的循环指令都是“短转移”，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围为：-128～127。 转移指令背后的思考根据位移进行转移的意义采用这种位移的设计，方便了程序段在内存中的浮动装配。如下程序所示：1234 mov cx,6 B9 06 00 mo ax,10h B8 10 00 s: add ax,ax 01 C0 loop s E2 FC ;前移了4个字节 这样的程序装在内存的不同位置都可正确执行。 编译器对转移位移超界的检测看如下代码：123start: jmp short s db 128 dup(0)s: mov ax,offffh 假设程序的入口在start处，那么在进行编译的时候，jmp指令标号s中间存在128字节的距离，而jmp short s的转移范围是-128～127,只能向后跳转127个字节，所以会编译报错。 后记通过对CPU工作原理的深入学习，实现在底层上真正的自由。 ——《编程语言》 王爽 著]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.6_汇编(CALL和RET指令)]]></title>
    <url>%2F2018%2F03%2F22%2F1.6_%E6%B1%87%E7%BC%96(CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4)%2F</url>
    <content type="text"><![CDATA[前言call和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP。他们经常被共同用来实现子程序的设计。下面将介绍call和ret指令的原理。 常用的转移指令#### 操作符offset 转移指令背后的思考 后记通过对CPU工作原理的深入学习，实现在底层上真正的自由。 ——《编程语言》 王爽 著]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2_汇编(loop)]]></title>
    <url>%2F2018%2F03%2F22%2F1.2_%E6%B1%87%E7%BC%96(loop)%2F</url>
    <content type="text"><![CDATA[loop定义CPU执行loop指令的时候，要进行两步操作: 1 (cx) = (cx) - 12 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行 其中，cx为CX寄存器。 编程案例编程计算2^12的值 assume cs:codecode segmentmov ax,2 mov cx,11s: add ax,axloop s mov ax,4c00hint 21hcode endsend 分析上述程序：在汇编语言中，标号代表一个地址，s即是此程序中的标号,在loop ： s语句中执行以下步骤： 1 (cx) = (cx) - 12 判断cx中的值，不为0则转至标号s所标识的地址处执行（这里的指令是add ax,ax），如果为零则执行下一条指令（下一条指令是mov ax,4c00h)。 此处add ax,ax指令共执行了11次。这里要注意的是,loop s 下面的语句是用来返回8086系统的cmd进程中的，与此处的知识点无关，如果有兴趣可以找时间研究。 2. 实验 编程，向内存0：200～0：23F依次传送数据0～63（3FH）。 实现上述功能，且不能超过9条指令，且指令中应该包括mov ax,4c00h 和 int 21h。 ——《编程语言》 王爽著]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.3_汇编(多段程序及内存定位)]]></title>
    <url>%2F2018%2F03%2F22%2F1.3_%E6%B1%87%E7%BC%96(%E5%A4%9A%E6%AE%B5%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%86%85%E5%AD%98%E5%AE%9A%E4%BD%8D)%20%2F</url>
    <content type="text"><![CDATA[多段程序我们现在知道内存可以数据段，代码段，栈空间；那么当我们在一个程序中同时包含数据和代码时，从内存角度来看，我们应该怎么解决这个问题呢？ 在一个段中存放数据、代码、栈； 将数据、代码、栈放入不同的段中。 在代码段中使用程序先看下列程序：123456789101112131415assume cs:codecode segment dw 0123h,0456h,0789h,0abch,0defh,ofedh,0cbah,0987h start: mov bx,0 mov bx,0 mov cx,0 s: add ax,cs:[bx] add bx,2 loop s mov ax,4c00h int 21hcode endsend start 需要说明的几个问题： 1 dw的含义是define word，在这里，使用dw定义了8个字型数据；2 end 后面的 start表明了程序的入口。end除了通知编译器程序在这里结束外，还可以通知编译器程序的入口在什么地方；3 通过这种方法生成的数据，这8个数据存在于代码段的最开始，所以偏移地址为0,然后依次递增，8个字型数据存在于代码段的偏移0，2，4，6，8，A，C，E处。 在代码段中使用栈程序的大概思路为先”dw”8个字型空间留给要用的数据，然后”dw”8个字型空的空间留做栈空间用。假如我们设计将cs:10～cs:2F用做栈空间，那么需要在初始化设置时将cs段地址赋予ss中（中间经过ax寄存器做桥梁），然后将sp指向30h。 将数据、代码、栈放入不同的段将数据、代码、栈都放在一起存在两个缺点： 把它们放到一个段中使程序显得混乱； 如果需要的空间超过64kb，既不能放在一个段中（8086模式中一个段的容量不能超过64kb）。 程序大概格式如下：12345678910111213141516171819assume cs:code,ds:data,ss:stackdata segment...data endsstack segment...stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,20h ;指向栈顶 mov ax,data mov ds,ax ;指向data段...code endsend start 这个代码一共定义了三段空间，通过名称“data”等来传递段地址，即在进行空间的定义的时候，在物理上就将三个空间分开，然后调用其相应的段地址即可。此处再进行强调依次，在对段地址寄存器进行操作的时候，不能直接对其赋值，而应通过ax等寄存器作为桥梁。 更灵活的内存定位基础知识点： and和or指令的用法； 通过db ‘（字母）’的形式将对应的ASCII码值提取出来，db的意思是define byte； 字母的大小写转换问题，仔细研究一下ASCII表中大小写字母的区别，差值固定； [bx + idata] 的意思是 [（bx）+ idata]（意义：为高级语言实现数组提供了便利机制）； 提供了SI，DI两个16位寄存器，但是这两个寄存器并不能拆分成两个8位寄存器，功能和BX相近； 结论： [idata]用一个常量来表示地址，可用于直接定位一个内存单元； [bx]用一个变量来表示内存地址，可用于间接定位一个内存单元； [bx+idata]用一个变量和常量表示地址，可在一个其实地址的基础上用变量简洁的定位一个内存单元； [bx+si]用两个变量表示地址； [bx+si+idata]用两个变量和一个常量表示地址。 ——《编程语言》 王爽 著]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.4_汇编(数据处理的两个基本问题)]]></title>
    <url>%2F2018%2F03%2F22%2F1.4_%E6%B1%87%E7%BC%96(%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[前言本章是对前面问题的一个总结。总结主要讨论以下两个问题。 处理的数据在什么地方？ 要处理的数据有多少？ 机器指令处理的数据放在什么地方？在考虑机器如何处理数据之前，我们首先需要考虑我们要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口（书籍的后半部分会进行讨论）。 立即数对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中称为“立即数”（idata），在汇编指令中直接给出。如下代码：1234mov ax,1add bx,2000hor bx,00010000bmov al,&apos;a&apos; 我的理解：数据可以以直接给出数据的形式展现出来，如上，一共涉及了4种格式：10进制数，16进制数，2进制数，ASCII码形式。 寄存器指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。如下代码：123456mov ax,bxmov ds,axmov ds:[0],bxpush bxpop ds 从寄存器里取出的值可以用来赋予普通寄存器，也可以用来存入某个地址的内存单元，也可以入栈等。 段地址（SA）和偏移地址（EA）如果指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。 指令要处理的数据有多长8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。可以用以下几个方法处理： 通过寄存器名指明要处理的数据的尺寸如果要处理的是字指令，那么使用16位寄存器如ax等进行中转；如果要处理的是字节指令，使用8位寄存器如al等进行中转。 可以用操作符指明数据长度运用操作符X ptr 指明内存单元的长度，X在汇编指令中可以为word或byte。例：1234mov word ptr ds:[0],1inc word ptr [bx]inc word ptr ds:[0]add word ptr [bx],2 1234mov byte ptr ds:[0],1mov byte ptr [bx]mov byte ptr ds:[0]mov byte ptr [bx],2 其它方法有些指令默认了的是字单元还是字节单元，比如，push [1000H]就不用指明访问的是字还是字节，因为push指令只进行字操作。 ——《编程语言》 王爽 著]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1_汇编(内存操作思考)]]></title>
    <url>%2F2018%2F03%2F21%2F1.1_%E6%B1%87%E7%BC%96(%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%80%9D%E8%80%83)%2F</url>
    <content type="text"><![CDATA[问题提出 存储在内存中的都是二进制数，如何区分指令，数据和栈空间？ 基础知识CS 和 IP定义CS是代码段寄存器，IP是指令指针寄存器。 用法如果需要到20003H处寻找指令，即CS：IP = 2000：0003。可以 jmp 2000:3, 此句执行后，CS = 2000H，IP=0003H，CPU将从20003H处读取指令。物理地址：20003H = 2000H（段地址） × 16 + 0003H（偏移地址）。（此处之所以×16是因为在8086CPU合成地址的规定，并不具备普遍意义。） 只要符合“段地址×规定倍率 + 偏移地址”格式得到的最终物理地址均有效，允许出现段地址与偏移地址不相同但是最终物理地址相同的情况。 注意事项 8086CPU的工作过程可以描述如下： 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲区； IP=IP+所读取的指令的长度，从而指向下一条指令； 执行指令。转到步骤1,重复这个过程。 在8086CPU中，无法直接对CS及IP寄存器进行操作，而通过“jmp 段地址：偏移地址”的指令进行对CS和IP寄存器的修改。 DS 和 [Adress]定义 CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086中，内存地址有段地址和偏移地址组成。 上段所说的指向数据内存的段地址寄存器为DS。 用法假如我们需要访问10000H单元的内容，可以用如下的程序段进行： mov bx,1000Hmov ds,bxmov al,[0] 上述的3条指令将10000H（1000：0）中的数据读到al。 注意事项完成上述指令目标时，为什么不能用下面的指令实现？ mov ds,1000H 即思考为什么不能将数值直接送入DS寄存器？关于这一点，这是因为8086的CPU硬件设计部分的原因，感兴趣可以自己进行寻找答案。 SS 和 SP定义8086CPU用SS和SP指示栈顶的位置，SS为段地址，SP为偏移地址。常与push和pop指令连在一起用。在这使用的过程中，假如我们定义的栈空间为指定大小x，栈空间的其实地址为a。那么可能出现栈满时执行push或着栈空的时候执行pop带来的“栈顶超界”问题，8086并没有提供有关记录栈顶空间的寄存器，需要编程者自己注意。 用法 mov ax,1000Hmov ss,axmov sp,0010Hpush axpush bxpush ds 上述指令执行了以下几个操作 将1000H放入AX寄存器 将栈段地址寄存器赋值1000H 将栈偏移地址寄存器赋值0010H 将AX寄存器的值压入栈 将BX寄存器的值压入栈 将DS寄存器的值压入栈 注意事项 在汇编操作的过程中，8086CPU并不支持直接将值赋予SS寄存器，但是可以直接将值赋予SP寄存器。 在入栈时，地址是从高向低增长。 思考 内存里是二进制数，并不具备所谓的数据、命令、栈空间的区别，全都是一个个的二进制数； 当CS、IP指向的是命令，DS、[Adress]指向的是数据，SS、SP指向栈空间的栈顶数据。 ——《汇编语言第三版》 王爽]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.0_汇编语言（写在前面）]]></title>
    <url>%2F2018%2F03%2F20%2F1.0_%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4)%2F</url>
    <content type="text"><![CDATA[前言因为最近实在是遇到了项目上的困难，加上在计算机领域的经验很少，隔行如隔山，只能抱着虚心学习的态度，从基础看起。 更新博文主要目的是为了自己回顾的时候可以少走写弯路，所得均是从书上阅读与思考。 因为总结的目的是很大部分是为了自己，所以在我已经熟知的知识上给予了跳过，但是这部分可能是很重要的知识。 如果有后来者希望仅仅通过这一系列文章即对汇编有个大致的了解，我希望大家可以通过渠道去阅读王爽的《汇编语言》，通俗易懂。 欢迎通过邮箱及其他平台进行交流:) ——《汇编语言第三版》 王爽]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
</search>
