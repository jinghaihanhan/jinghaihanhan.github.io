<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[3月27准备工作]]></title>
    <url>%2F2018%2F03%2F27%2F3_27%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[最近在忙得一些事最近在忙着撰写文档，本来已经开始中的烧录加密任务也暂时停止了，等文档写完了就开始总结卡尔曼滤波的学习过程。 准备新开的事情今天开始每天晚上固定学习数学，从今天开始更新。英语的话，我先查查单词等等。]]></content>
      <categories>
        <category>日常随笔</category>
      </categories>
      <tags>
        <tag>心路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu（命令及桌面整理）]]></title>
    <url>%2F2018%2F03%2F23%2FUbuntu%EF%BC%88%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%A1%8C%E9%9D%A2%E6%95%B4%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[遇到的困难 电脑屏幕太小，想同时进行文档查看和文档撰写，特别不方便。 每次上传文件，都需要到目标文件夹里面去执行终端命令，感觉很繁琐。 解决问题的办法 下载了一个ubuntu的unity管理系统——Unity Tweak Tools。实现了以下几个功能： 1 可以自由的更换系统主题，主题图标；2 可以增加工作空间，快捷键ctrl+s，可以多设立几个工作空间，然后将不同的任务进行分配； 通过编写命令集合的shell文件来实现目的：比如我需要实现不用去目标文件夹即可以上传备份工作文件的目的： 1 先将要存放shell脚本的文件夹建立好，复制文件夹的路经；2 打开～目录下的.bashrc文件，加入路径作为环境变量（具体设置方法可以百度，此处只提供思路）；3 然后编写shell脚本，如我的脚本就是“声明，切换目录到指定文件夹，输入对应指令”；4 然后在任一地方打开终端，输入指令source [文件名]即可。（source bash sh都可，但取决于你定义的shell脚本的声明）。]]></content>
      <categories>
        <category>日常随笔</category>
      </categories>
      <tags>
        <tag>ubuntu桌面</tag>
        <tag>ubuntu命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.6_汇编(CALL和RET指令)]]></title>
    <url>%2F2018%2F03%2F22%2F1.6_%E6%B1%87%E7%BC%96(CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4)%2F</url>
    <content type="text"><![CDATA[前言call和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP。他们经常被共同用来实现子程序的设计。下面将介绍call和ret指令的原理。 常用的转移指令#### 操作符offset 转移指令背后的思考 后记通过对CPU工作原理的深入学习，实现在底层上真正的自由。 ——《编程语言》 王爽 著]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.5_汇编(转移指令的原理)]]></title>
    <url>%2F2018%2F03%2F22%2F1.5_%E6%B1%87%E7%BC%96(%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86)%2F</url>
    <content type="text"><![CDATA[前言可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括的说，转移指令就是可以控制CPU执行内存中某处代码的指令。8086CPU的转移指令分为以下几类： 段间转移和段内转移段内转移分两种：短转移和近转移` 常用的转移指令操作符offset操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。给出下列程序段，填写两条指令，使该程序在运行中将s处的一条指令复制到s0处。1234567891011assume cs:codesg codesg segment s: mov ax,bx mov si,offset s mov di,offset s0 __________ __________ s0: nop nop codesg ends end s 提出以下几个问题： s和s0处的指令所在的内存单元的地址是多少？ 将s处的指令复制到s0处，如何进行操作？ 段地址已知在cs中，偏移地址offset s和offset s0已经送入si和di中。 要复制的数据有多长？ 思考所得： 通过“offset 标号”可以得到标号的地址； 在8086CPU中，得到的标号地址是八位数据。 jmp指令 根据位移进行转移的jmp指令jmp short 标号（转到标号处执行指令）这种情况下执行的jmp指令在机器指令里的跳转数据并不是目标程序（或标号）的地址，而是相对偏移地址，比如jmp的前一句指令的地址为a，跳转的目标指令的地址为b，在机器指令里，只出现b-a的值，并不直接指明地址b。这说明，CPU在执行jmp指令的时候并不需要转移的目的地址。 转移的目的地址在指令中的jmp指令jmp far ptr 标号上述指令实现的是段间转移，又称为远转移。可以同时修改CS和IP。 转移地址在寄存器中的jmp指令指令格式：jmp 16位reg这种修改方式只能修改IP，并不能修改CS 转移地址在内存中的jmp指令a、jmp word ptr 内存单元地址（段内转移）在内存单元地址处开始存放着一个字b、jmp dword ptr 内存单元地址（段间转移）在内存单元地址处开始存放着两个字 我是否可以这么理解？当我提供给jmp16位数据时，只进行IP的修改，即进行段内转移，当你提供给它32位数据时，它填满了IP，即会填充CS，实现段间转移。 jcxz条件转移指令jcxz 标号（如果（cx）==0,转移到标号处执行） loop指令loop指令为循环指令，所有的循环指令都是“短转移”，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围为：-128～127。 转移指令背后的思考根据位移进行转移的意义采用这种位移的设计，方便了程序段在内存中的浮动装配。如下程序所示：1234 mov cx,6 B9 06 00 mo ax,10h B8 10 00 s: add ax,ax 01 C0 loop s E2 FC ;前移了4个字节 这样的程序装在内存的不同位置都可正确执行。 编译器对转移位移超界的检测看如下代码：123start: jmp short s db 128 dup(0)s: mov ax,offffh 假设程序的入口在start处，那么在进行编译的时候，jmp指令标号s中间存在128字节的距离，而jmp short s的转移范围是-128～127,只能向后跳转127个字节，所以会编译报错。 后记通过对CPU工作原理的深入学习，实现在底层上真正的自由。 ——《编程语言》 王爽 著]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.4_汇编(数据处理的两个基本问题)]]></title>
    <url>%2F2018%2F03%2F22%2F1.4_%E6%B1%87%E7%BC%96(%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98)%2F</url>
    <content type="text"><![CDATA[前言本章是对前面问题的一个总结。总结主要讨论以下两个问题。 处理的数据在什么地方？ 要处理的数据有多少？ 机器指令处理的数据放在什么地方？在考虑机器如何处理数据之前，我们首先需要考虑我们要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口（书籍的后半部分会进行讨论）。 立即数对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中称为“立即数”（idata），在汇编指令中直接给出。如下代码：1234mov ax,1add bx,2000hor bx,00010000bmov al,&apos;a&apos; 我的理解：数据可以以直接给出数据的形式展现出来，如上，一共涉及了4种格式：10进制数，16进制数，2进制数，ASCII码形式。 寄存器指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。如下代码：123456mov ax,bxmov ds,axmov ds:[0],bxpush bxpop ds 从寄存器里取出的值可以用来赋予普通寄存器，也可以用来存入某个地址的内存单元，也可以入栈等。 段地址（SA）和偏移地址（EA）如果指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。 指令要处理的数据有多长8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。可以用以下几个方法处理： 通过寄存器名指明要处理的数据的尺寸如果要处理的是字指令，那么使用16位寄存器如ax等进行中转；如果要处理的是字节指令，使用8位寄存器如al等进行中转。 可以用操作符指明数据长度运用操作符X ptr 指明内存单元的长度，X在汇编指令中可以为word或byte。例：1234mov word ptr ds:[0],1inc word ptr [bx]inc word ptr ds:[0]add word ptr [bx],2 1234mov byte ptr ds:[0],1mov byte ptr [bx]mov byte ptr ds:[0]mov byte ptr [bx],2 其它方法有些指令默认了的是字单元还是字节单元，比如，push [1000H]就不用指明访问的是字还是字节，因为push指令只进行字操作。 ——《编程语言》 王爽 著]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.3_汇编(多段程序及内存定位)]]></title>
    <url>%2F2018%2F03%2F22%2F1.3_%E6%B1%87%E7%BC%96(%E5%A4%9A%E6%AE%B5%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%86%85%E5%AD%98%E5%AE%9A%E4%BD%8D)%20%2F</url>
    <content type="text"><![CDATA[多段程序我们现在知道内存可以数据段，代码段，栈空间；那么当我们在一个程序中同时包含数据和代码时，从内存角度来看，我们应该怎么解决这个问题呢？ 在一个段中存放数据、代码、栈； 将数据、代码、栈放入不同的段中。 在代码段中使用程序先看下列程序：123456789101112131415assume cs:codecode segment dw 0123h,0456h,0789h,0abch,0defh,ofedh,0cbah,0987h start: mov bx,0 mov bx,0 mov cx,0 s: add ax,cs:[bx] add bx,2 loop s mov ax,4c00h int 21hcode endsend start 需要说明的几个问题： 1 dw的含义是define word，在这里，使用dw定义了8个字型数据；2 end 后面的 start表明了程序的入口。end除了通知编译器程序在这里结束外，还可以通知编译器程序的入口在什么地方；3 通过这种方法生成的数据，这8个数据存在于代码段的最开始，所以偏移地址为0,然后依次递增，8个字型数据存在于代码段的偏移0，2，4，6，8，A，C，E处。 在代码段中使用栈程序的大概思路为先”dw”8个字型空间留给要用的数据，然后”dw”8个字型空的空间留做栈空间用。假如我们设计将cs:10～cs:2F用做栈空间，那么需要在初始化设置时将cs段地址赋予ss中（中间经过ax寄存器做桥梁），然后将sp指向30h。 将数据、代码、栈放入不同的段将数据、代码、栈都放在一起存在两个缺点： 把它们放到一个段中使程序显得混乱； 如果需要的空间超过64kb，既不能放在一个段中（8086模式中一个段的容量不能超过64kb）。 程序大概格式如下：12345678910111213141516171819assume cs:code,ds:data,ss:stackdata segment...data endsstack segment...stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,20h ;指向栈顶 mov ax,data mov ds,ax ;指向data段...code endsend start 这个代码一共定义了三段空间，通过名称“data”等来传递段地址，即在进行空间的定义的时候，在物理上就将三个空间分开，然后调用其相应的段地址即可。此处再进行强调依次，在对段地址寄存器进行操作的时候，不能直接对其赋值，而应通过ax等寄存器作为桥梁。 更灵活的内存定位基础知识点： and和or指令的用法； 通过db ‘（字母）’的形式将对应的ASCII码值提取出来，db的意思是define byte； 字母的大小写转换问题，仔细研究一下ASCII表中大小写字母的区别，差值固定； [bx + idata] 的意思是 [（bx）+ idata]（意义：为高级语言实现数组提供了便利机制）； 提供了SI，DI两个16位寄存器，但是这两个寄存器并不能拆分成两个8位寄存器，功能和BX相近； 结论： [idata]用一个常量来表示地址，可用于直接定位一个内存单元； [bx]用一个变量来表示内存地址，可用于间接定位一个内存单元； [bx+idata]用一个变量和常量表示地址，可在一个其实地址的基础上用变量简洁的定位一个内存单元； [bx+si]用两个变量表示地址； [bx+si+idata]用两个变量和一个常量表示地址。 ——《编程语言》 王爽 著]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2_汇编(loop)]]></title>
    <url>%2F2018%2F03%2F22%2F1.2_%E6%B1%87%E7%BC%96(loop)%2F</url>
    <content type="text"><![CDATA[loop定义CPU执行loop指令的时候，要进行两步操作: 1 (cx) = (cx) - 12 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行 其中，cx为CX寄存器。 编程案例编程计算2^12的值 assume cs:codecode segmentmov ax,2 mov cx,11s: add ax,axloop s mov ax,4c00hint 21hcode endsend 分析上述程序：在汇编语言中，标号代表一个地址，s即是此程序中的标号,在loop ： s语句中执行以下步骤： 1 (cx) = (cx) - 12 判断cx中的值，不为0则转至标号s所标识的地址处执行（这里的指令是add ax,ax），如果为零则执行下一条指令（下一条指令是mov ax,4c00h)。 此处add ax,ax指令共执行了11次。这里要注意的是,loop s 下面的语句是用来返回8086系统的cmd进程中的，与此处的知识点无关，如果有兴趣可以找时间研究。 2. 实验 编程，向内存0：200～0：23F依次传送数据0～63（3FH）。 实现上述功能，且不能超过9条指令，且指令中应该包括mov ax,4c00h 和 int 21h。 ——《编程语言》 王爽著]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1_汇编(内存操作思考)]]></title>
    <url>%2F2018%2F03%2F21%2F1.1_%E6%B1%87%E7%BC%96(%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%80%9D%E8%80%83)%2F</url>
    <content type="text"><![CDATA[问题提出 存储在内存中的都是二进制数，如何区分指令，数据和栈空间？ 基础知识CS 和 IP定义CS是代码段寄存器，IP是指令指针寄存器。 用法如果需要到20003H处寻找指令，即CS：IP = 2000：0003。可以 jmp 2000:3, 此句执行后，CS = 2000H，IP=0003H，CPU将从20003H处读取指令。物理地址：20003H = 2000H（段地址） × 16 + 0003H（偏移地址）。（此处之所以×16是因为在8086CPU合成地址的规定，并不具备普遍意义。） 只要符合“段地址×规定倍率 + 偏移地址”格式得到的最终物理地址均有效，允许出现段地址与偏移地址不相同但是最终物理地址相同的情况。 注意事项 8086CPU的工作过程可以描述如下： 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲区； IP=IP+所读取的指令的长度，从而指向下一条指令； 执行指令。转到步骤1,重复这个过程。 在8086CPU中，无法直接对CS及IP寄存器进行操作，而通过“jmp 段地址：偏移地址”的指令进行对CS和IP寄存器的修改。 DS 和 [Adress]定义 CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086中，内存地址有段地址和偏移地址组成。 上段所说的指向数据内存的段地址寄存器为DS。 用法假如我们需要访问10000H单元的内容，可以用如下的程序段进行： mov bx,1000Hmov ds,bxmov al,[0] 上述的3条指令将10000H（1000：0）中的数据读到al。 注意事项完成上述指令目标时，为什么不能用下面的指令实现？ mov ds,1000H 即思考为什么不能将数值直接送入DS寄存器？关于这一点，这是因为8086的CPU硬件设计部分的原因，感兴趣可以自己进行寻找答案。 SS 和 SP定义8086CPU用SS和SP指示栈顶的位置，SS为段地址，SP为偏移地址。常与push和pop指令连在一起用。在这使用的过程中，假如我们定义的栈空间为指定大小x，栈空间的其实地址为a。那么可能出现栈满时执行push或着栈空的时候执行pop带来的“栈顶超界”问题，8086并没有提供有关记录栈顶空间的寄存器，需要编程者自己注意。 用法 mov ax,1000Hmov ss,axmov sp,0010Hpush axpush bxpush ds 上述指令执行了以下几个操作 将1000H放入AX寄存器 将栈段地址寄存器赋值1000H 将栈偏移地址寄存器赋值0010H 将AX寄存器的值压入栈 将BX寄存器的值压入栈 将DS寄存器的值压入栈 注意事项 在汇编操作的过程中，8086CPU并不支持直接将值赋予SS寄存器，但是可以直接将值赋予SP寄存器。 在入栈时，地址是从高向低增长。 思考 内存里是二进制数，并不具备所谓的数据、命令、栈空间的区别，全都是一个个的二进制数； 当CS、IP指向的是命令，DS、[Adress]指向的是数据，SS、SP指向栈空间的栈顶数据。 ——《汇编语言第三版》 王爽]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.0_汇编语言（写在前面）]]></title>
    <url>%2F2018%2F03%2F20%2F1.0_%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4)%2F</url>
    <content type="text"><![CDATA[前言因为最近实在是遇到了项目上的困难，加上在计算机领域的经验很少，隔行如隔山，只能抱着虚心学习的态度，从基础看起。 更新博文主要目的是为了自己回顾的时候可以少走写弯路，所得均是从书上阅读与思考。 因为总结的目的是很大部分是为了自己，所以在我已经熟知的知识上给予了跳过，但是这部分可能是很重要的知识。 如果有后来者希望仅仅通过这一系列文章即对汇编有个大致的了解，我希望大家可以通过渠道去阅读王爽的《汇编语言》，通俗易懂。 欢迎通过邮箱及其他平台进行交流:) ——《汇编语言第三版》 王爽]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
</search>
